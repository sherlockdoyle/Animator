"""This module provides an interface to the Skia text layout library."""
from __future__ import annotations

import typing
from enum import IntEnum

import animator.skia
from animator.skia import _Color, _Point

__all__ = [
    'Affinity',
    'Block',
    'Decoration',
    'FontArguments',
    'FontCollection',
    'FontFeature',
    'LineMetricStyle',
    'LineMetrics',
    'Paragraph',
    'ParagraphBuilder',
    'ParagraphStyle',
    'Placeholder',
    'PlaceholderAlignment',
    'PlaceholderStyle',
    'PositionWithAffinity',
    'Range',
    'RectHeightStyle',
    'RectWidthStyle',
    'StrutStyle',
    'StyleMetrics',
    'StyleType',
    'TextAlign',
    'TextBaseline',
    'TextBox',
    'TextDecoration',
    'TextDecorationMode',
    'TextDecorationStyle',
    'TextDirection',
    'TextHeightBehavior',
    'TextShadow',
    'TextStyle',
]

class Affinity:
    """
    Members:

      kUpstream

      kDownstream
    """

    __members__: typing.ClassVar[
        dict[str, Affinity]
    ]  # value = {'kUpstream': <Affinity.kUpstream: 0>, 'kDownstream': <Affinity.kDownstream: 1>}
    kDownstream: typing.ClassVar[Affinity]  # value = <Affinity.kDownstream: 1>
    kUpstream: typing.ClassVar[Affinity]  # value = <Affinity.kUpstream: 0>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Block:
    fRange: Range
    fStyle: TextStyle
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, start: int, end: int, style: TextStyle) -> None: ...
    @typing.overload
    def __init__(self, range: Range, style: TextStyle) -> None: ...
    def __str__(self) -> str: ...
    def add(self, tail: Range) -> None: ...

class Decoration:
    __hash__: typing.ClassVar[None] = None
    fColor: int
    fMode: TextDecorationMode
    fStyle: TextDecorationStyle
    fThicknessMultiplier: float
    fType: TextDecoration
    def __eq__(self, arg0: Decoration) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        type: TextDecoration = TextDecoration.kNoDecoration,
        mode: TextDecorationMode = TextDecorationMode.kGaps,
        color: _Color = animator.skia.ColorTRANSPARENT,
        style: TextDecorationStyle = TextDecorationStyle.kSolid,
        thicknessMultiplier: float = 0,
    ) -> None: ...
    def __str__(self) -> str: ...

class FontArguments:
    __hash__: typing.ClassVar[None] = None
    def CloneTypeface(self, typeface: animator.skia.Typeface) -> animator.skia.Typeface: ...
    def __eq__(self, arg0: FontArguments) -> bool: ...
    @typing.overload
    def __init__(self, arg0: animator.skia.FontArguments) -> None: ...
    @typing.overload
    def __init__(self, arg0: FontArguments) -> None: ...
    def __ne__(self, arg0: FontArguments) -> bool: ...

class FontCollection:
    def __init__(self) -> None: ...
    def __str__(self) -> str: ...
    def clearCaches(self) -> None: ...
    def defaultEmojiFallback(
        self, emojiStart: int, fontStyle: animator.skia.FontStyle, locale: str
    ) -> animator.skia.Typeface: ...
    @typing.overload
    def defaultFallback(
        self, unicode: int, fontStyle: animator.skia.FontStyle, locale: str
    ) -> animator.skia.Typeface: ...
    @typing.overload
    def defaultFallback(self) -> animator.skia.Typeface: ...
    def disableFontFallback(self) -> None: ...
    def enableFontFallback(self) -> None: ...
    @typing.overload
    def findTypefaces(
        self, familyNames: list[str], fontStyle: animator.skia.FontStyle
    ) -> list[animator.skia.Typeface]: ...
    @typing.overload
    def findTypefaces(
        self, familyNames: list[str], fontStyle: animator.skia.FontStyle, fontArgs: FontArguments | None
    ) -> list[animator.skia.Typeface]: ...
    def fontFallbackEnabled(self) -> bool: ...
    def getFallbackManager(self) -> animator.skia.FontMgr: ...
    def getFontManagersCount(self) -> int: ...
    def setAssetFontManager(self, fontManager: animator.skia.FontMgr) -> None: ...
    @typing.overload
    def setDefaultFontManager(self, fontManager: animator.skia.FontMgr) -> None: ...
    @typing.overload
    def setDefaultFontManager(self, fontManager: animator.skia.FontMgr, defaultFamilyName: str) -> None: ...
    @typing.overload
    def setDefaultFontManager(self, fontManager: animator.skia.FontMgr, defaultFamilyNames: list[str]) -> None: ...
    def setDynamicFontManager(self, fontManager: animator.skia.FontMgr) -> None: ...
    def setTestFontManager(self, fontManager: animator.skia.FontMgr) -> None: ...

class FontFeature:
    __hash__: typing.ClassVar[None] = None
    fName: str
    fValue: int
    def __eq__(self, arg0: FontFeature) -> bool: ...
    def __init__(self, name: str, value: int) -> None: ...
    def __str__(self) -> str: ...

class LineMetricStyle:
    """
    Members:

      Typographic

      CSS
    """

    CSS: typing.ClassVar[LineMetricStyle]  # value = <LineMetricStyle.CSS: 1>
    Typographic: typing.ClassVar[LineMetricStyle]  # value = <LineMetricStyle.Typographic: 0>
    __members__: typing.ClassVar[
        dict[str, LineMetricStyle]
    ]  # value = {'Typographic': <LineMetricStyle.Typographic: 0>, 'CSS': <LineMetricStyle.CSS: 1>}
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LineMetrics:
    fAscent: float
    fBaseline: float
    fDescent: float
    fEndExcludingWhitespaces: int
    fEndIncludingNewline: int
    fEndIndex: int
    fHardBreak: bool
    fHeight: float
    fLeft: float
    fLineMetrics: dict[int, StyleMetrics]
    fLineNumber: int
    fStartIndex: int
    fUnscaledAscent: float
    fWidth: float
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        start: int = 0,
        end: int = 0,
        end_excluding_whitespaces: int = 0,
        end_including_newline: int = 0,
        hard_break: bool = False,
    ) -> None: ...
    def __str__(self) -> str: ...

class Paragraph:
    class ExtendedVisitorInfo:
        def __str__(self) -> str: ...
        @property
        def advance(self) -> animator.skia.Size: ...
        @property
        def bounds(self) -> list[animator.skia.Rect]: ...
        @property
        def count(self) -> int: ...
        @property
        def flags(self) -> Paragraph.VisitorFlags: ...
        @property
        def font(self) -> animator.skia.Font:
            """
            TODO: How to bind reference fields? There's probably some memory leak here.
            """
        @property
        def glyphs(self) -> list[int]: ...
        @property
        def origin(self) -> animator.skia.Point: ...
        @property
        def positions(self) -> list[animator.skia.Point]: ...
        @property
        def utf8Starts(self) -> list[int]: ...

    class FontInfo:
        fFont: animator.skia.Font
        fTextRange: Range
        @typing.overload
        def __init__(self, font: animator.skia.Font, textRange: Range) -> None: ...
        @typing.overload
        def __init__(self, other: Paragraph.FontInfo) -> None: ...
        def __str__(self) -> str: ...

    class GlyphClusterInfo:
        def __str__(self) -> str: ...
        @property
        def fBounds(self) -> animator.skia.Rect: ...
        @property
        def fClusterTextRange(self) -> Range: ...
        @property
        def fGlyphClusterPosition(self) -> TextDirection: ...

    class GlyphInfo:
        def __str__(self) -> str: ...
        @property
        def fDirection(self) -> TextDirection: ...
        @property
        def fGraphemeClusterTextRange(self) -> Range: ...
        @property
        def fGraphemeLayoutBounds(self) -> animator.skia.Rect: ...
        @property
        def fIsEllipsis(self) -> bool: ...

    class VisitorFlags(IntEnum):
        """
        Members:

          kWhiteSpace_VisitorFlag
        """

        __members__: typing.ClassVar[
            dict[str, Paragraph.VisitorFlags]
        ]  # value = {'kWhiteSpace_VisitorFlag': <VisitorFlags.kWhiteSpace_VisitorFlag: 1>}
        kWhiteSpace_VisitorFlag: typing.ClassVar[
            Paragraph.VisitorFlags
        ]  # value = <VisitorFlags.kWhiteSpace_VisitorFlag: 1>
        def __and__(self, other: typing.Any) -> typing.Any: ...
        def __eq__(self, other: typing.Any) -> bool: ...
        def __ge__(self, other: typing.Any) -> bool: ...
        def __getstate__(self) -> int: ...
        def __gt__(self, other: typing.Any) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> typing.Any: ...
        def __le__(self, other: typing.Any) -> bool: ...
        def __lt__(self, other: typing.Any) -> bool: ...
        def __ne__(self, other: typing.Any) -> bool: ...
        def __or__(self, other: typing.Any) -> typing.Any: ...
        def __rand__(self, other: typing.Any) -> typing.Any: ...
        def __repr__(self) -> str: ...
        def __ror__(self, other: typing.Any) -> typing.Any: ...
        def __rxor__(self, other: typing.Any) -> typing.Any: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        def __xor__(self, other: typing.Any) -> typing.Any: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class VisitorInfo:
        def __str__(self) -> str: ...
        @property
        def advanceX(self) -> float: ...
        @property
        def count(self) -> int: ...
        @property
        def flags(self) -> Paragraph.VisitorFlags: ...
        @property
        def font(self) -> animator.skia.Font:
            """
            TODO: How to bind reference fields? There's probably some memory leak here.
            """
        @property
        def glyphs(self) -> list[int]: ...
        @property
        def origin(self) -> animator.skia.Point: ...
        @property
        def positions(self) -> list[animator.skia.Point]: ...
        @property
        def utf8Starts(self) -> list[int]: ...

    @staticmethod
    def GetPath(textBlob: animator.skia.TextBlob) -> animator.skia.Path: ...
    def __init__(self, style: ParagraphStyle, fonts: FontCollection) -> None: ...
    def __str__(self) -> str: ...
    def containsColorFontOrBitmap(self, textBlob: animator.skia.TextBlob) -> bool: ...
    def containsEmoji(self, textBlob: animator.skia.TextBlob) -> bool: ...
    def didExceedMaxLines(self) -> bool: ...
    def extendVisit(self) -> list:
        """
        Returns a list of (lineNumber, extendedVisitorInfo) tuples.
        """
    def getActualTextRange(self, lineNumber: int, includeSpaces: bool) -> Range: ...
    def getAlphabeticBaseline(self) -> float: ...
    def getClosestGlyphClusterAt(self, dx: float, dy: float) -> Paragraph.GlyphClusterInfo | None: ...
    def getClosestUTF16GlyphInfoAt(self, arg0: float, arg1: float) -> Paragraph.GlyphInfo | None: ...
    def getFontAt(self, codeUnitIndex: int) -> animator.skia.Font: ...
    def getFontAtUTF16Offset(self, codeUnitIndex: int) -> animator.skia.Font: ...
    def getFonts(self) -> list[Paragraph.FontInfo]: ...
    def getGlyphClusterAt(self, codeUnitIndex: int) -> Paragraph.GlyphClusterInfo | None: ...
    def getGlyphInfoAtUTF16Offset(self, arg0: int) -> Paragraph.GlyphInfo | None: ...
    def getGlyphPositionAtCoordinate(self, dx: float, dy: float) -> PositionWithAffinity: ...
    def getHeight(self) -> float: ...
    def getIdeographicBaseline(self) -> float: ...
    def getLineMetrics(self) -> list[LineMetrics]: ...
    def getLineMetricsAt(self, lineNumber: int) -> LineMetrics | None:
        """
        Returns line metrics info for the line, or `None` if the line is not found.
        """
    def getLineNumberAt(self, codeUnitIndex: int) -> int: ...
    def getLineNumberAtUTF16Offset(self, codeUnitIndex: int) -> int: ...
    def getLongestLine(self) -> float: ...
    def getMaxIntrinsicWidth(self) -> float: ...
    def getMaxWidth(self) -> float: ...
    def getMinIntrinsicWidth(self) -> float: ...
    def getPath(self, lineNumber: int) -> tuple:
        """
        Returns a tuple of (path, number of glyphs that could not be converted).
        """
    def getRectsForPlaceholders(self) -> list[TextBox]: ...
    def getRectsForRange(
        self, start: int, end: int, rectHeightStyle: RectHeightStyle, rectWidthStyle: RectWidthStyle
    ) -> list[TextBox]: ...
    def getWordBoundary(self, offset: int) -> Range: ...
    def layout(self, width: float) -> None: ...
    def lineNumber(self) -> int: ...
    def markDirty(self) -> None: ...
    def paint(self, canvas: animator.skia.Canvas, x: float, y: float) -> None: ...
    def unresolvedGlyphs(self) -> int: ...
    def updateBackgroundPaint(self, from_: int, to: int, paint: animator.skia.Paint) -> None: ...
    def updateFontSize(self, from_: int, to: int, fontSize: float) -> None: ...
    def updateForegroundPaint(self, from_: int, to: int, paint: animator.skia.Paint) -> None: ...
    def updateTextAlign(self, textAlign: TextAlign) -> None: ...
    def visit(self) -> list:
        """
        Returns a list of (lineNumber, visitorInfo) tuples.
        """

class ParagraphBuilder:
    @staticmethod
    def make(style: ParagraphStyle, fontCollection: FontCollection) -> ParagraphBuilder: ...
    def Build(self) -> Paragraph: ...
    def Reset(self) -> None: ...
    @typing.overload
    def __init__(self, style: ParagraphStyle, fontCollection: FontCollection) -> None: ...
    @typing.overload
    def __init__(self, style: ParagraphStyle, fontMgr: animator.skia.FontMgr) -> None: ...
    def __str__(self) -> str: ...
    def addPlaceholder(self, placeholderStyle: PlaceholderStyle) -> None: ...
    def addText(self, text: str) -> None: ...
    def getParagraphStyle(self) -> ParagraphStyle: ...
    def getText(self) -> str: ...
    def peekStyle(self) -> TextStyle: ...
    def pop(self) -> None: ...
    def pushStyle(self, style: TextStyle) -> None: ...

class ParagraphStyle:
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, arg0: ParagraphStyle) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        strutStyle: StrutStyle | None = None,
        textStyle: TextStyle | None = None,
        textDirection: TextDirection | None = None,
        textAlign: TextAlign | None = None,
        maxLines: int | None = None,
        ellipsis: str | None = None,
        height: float | None = None,
        textHeightBehavior: TextHeightBehavior | None = None,
        replaceTabCharacters: bool | None = None,
        applyRoundingHack: bool | None = None,
    ) -> None:
        """
        Construct a new paragraph style from keyword arguments. This creates a new :py:class:`ParagraphStyle`
        object and calls the respective setters for each keyword argument.
        """
    def __str__(self) -> str: ...
    def effective_align(self) -> TextAlign: ...
    def ellipsized(self) -> bool: ...
    def getApplyRoundingHack(self) -> bool: ...
    def getEllipsis(self) -> str: ...
    def getEllipsisUtf16(self) -> str: ...
    def getHeight(self) -> float: ...
    def getMaxLines(self) -> int: ...
    def getReplaceTabCharacters(self) -> bool: ...
    def getStrutStyle(self) -> StrutStyle: ...
    def getTextAlign(self) -> TextAlign: ...
    def getTextDirection(self) -> TextDirection: ...
    def getTextHeightBehavior(self) -> TextHeightBehavior: ...
    def getTextStyle(self) -> TextStyle: ...
    def hintingIsOn(self) -> bool: ...
    def setApplyRoundingHack(self, value: bool) -> None: ...
    def setEllipsis(self, ellipsis: str) -> None: ...
    def setHeight(self, height: float) -> None: ...
    def setMaxLines(self, maxLines: int) -> None: ...
    def setReplaceTabCharacters(self, value: bool) -> None: ...
    def setStrutStyle(self, strutStyle: StrutStyle) -> None: ...
    def setTextAlign(self, align: TextAlign) -> None: ...
    def setTextDirection(self, direction: TextDirection) -> None: ...
    def setTextHeightBehavior(self, v: TextHeightBehavior) -> None: ...
    def setTextStyle(self, textStyle: TextStyle) -> None: ...
    def turnHintingOff(self) -> None: ...
    def unlimited_lines(self) -> bool: ...

class Placeholder:
    fBlocksBefore: Range
    fRange: Range
    fStyle: PlaceholderStyle
    fTextBefore: Range
    fTextStyle: TextStyle
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        start: int,
        end: int,
        style: PlaceholderStyle,
        textStyle: TextStyle,
        blocksBefore: Range,
        textBefore: Range,
    ) -> None: ...
    def __str__(self) -> str: ...

class PlaceholderAlignment:
    """
    Members:

      kBaseline

      kAboveBaseline

      kBelowBaseline

      kTop

      kBottom

      kMiddle
    """

    __members__: typing.ClassVar[
        dict[str, PlaceholderAlignment]
    ]  # value = {'kBaseline': <PlaceholderAlignment.kBaseline: 0>, 'kAboveBaseline': <PlaceholderAlignment.kAboveBaseline: 1>, 'kBelowBaseline': <PlaceholderAlignment.kBelowBaseline: 2>, 'kTop': <PlaceholderAlignment.kTop: 3>, 'kBottom': <PlaceholderAlignment.kBottom: 4>, 'kMiddle': <PlaceholderAlignment.kMiddle: 5>}
    kAboveBaseline: typing.ClassVar[PlaceholderAlignment]  # value = <PlaceholderAlignment.kAboveBaseline: 1>
    kBaseline: typing.ClassVar[PlaceholderAlignment]  # value = <PlaceholderAlignment.kBaseline: 0>
    kBelowBaseline: typing.ClassVar[PlaceholderAlignment]  # value = <PlaceholderAlignment.kBelowBaseline: 2>
    kBottom: typing.ClassVar[PlaceholderAlignment]  # value = <PlaceholderAlignment.kBottom: 4>
    kMiddle: typing.ClassVar[PlaceholderAlignment]  # value = <PlaceholderAlignment.kMiddle: 5>
    kTop: typing.ClassVar[PlaceholderAlignment]  # value = <PlaceholderAlignment.kTop: 3>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PlaceholderStyle:
    __hash__: typing.ClassVar[None] = None
    fAlignment: PlaceholderAlignment
    fBaseline: TextBaseline
    fBaselineOffset: float
    fHeight: float
    fWidth: float
    def __eq__(self, arg0: PlaceholderStyle) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        width: float = 0,
        height: float = 0,
        alignment: PlaceholderAlignment = PlaceholderAlignment.kBaseline,
        baseline: TextBaseline = TextBaseline.kAlphabetic,
        offset: float = 0,
    ) -> None: ...
    def __str__(self) -> str: ...
    def equals(self, other: PlaceholderStyle) -> bool: ...

class PositionWithAffinity:
    affinity: Affinity
    position: int
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, position: int = 0, affinity: Affinity = Affinity.kDownstream) -> None: ...
    def __str__(self) -> str: ...

class Range:
    __hash__: typing.ClassVar[None] = None
    end: int
    start: int
    def Shift(self, arg0: int) -> None: ...
    def __and__(self, arg0: Range) -> Range: ...
    def __contains__(self, arg0: Range) -> bool: ...
    def __eq__(self, arg0: Range) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, start: int, end: int) -> None: ...
    @typing.overload
    def __init__(self, arg0: tuple) -> None: ...
    def __str__(self) -> str: ...
    def contains(self, other: Range) -> bool: ...
    def empty(self) -> bool: ...
    def intersection(self, other: Range) -> Range: ...
    def intersects(self, other: Range) -> bool: ...
    def width(self) -> int: ...

class RectHeightStyle:
    """
    Members:

      kTight

      kMax

      kIncludeLineSpacingMiddle

      kIncludeLineSpacingTop

      kIncludeLineSpacingBottom

      kStrut
    """

    __members__: typing.ClassVar[
        dict[str, RectHeightStyle]
    ]  # value = {'kTight': <RectHeightStyle.kTight: 0>, 'kMax': <RectHeightStyle.kMax: 1>, 'kIncludeLineSpacingMiddle': <RectHeightStyle.kIncludeLineSpacingMiddle: 2>, 'kIncludeLineSpacingTop': <RectHeightStyle.kIncludeLineSpacingTop: 3>, 'kIncludeLineSpacingBottom': <RectHeightStyle.kIncludeLineSpacingBottom: 4>, 'kStrut': <RectHeightStyle.kStrut: 5>}
    kIncludeLineSpacingBottom: typing.ClassVar[
        RectHeightStyle
    ]  # value = <RectHeightStyle.kIncludeLineSpacingBottom: 4>
    kIncludeLineSpacingMiddle: typing.ClassVar[
        RectHeightStyle
    ]  # value = <RectHeightStyle.kIncludeLineSpacingMiddle: 2>
    kIncludeLineSpacingTop: typing.ClassVar[RectHeightStyle]  # value = <RectHeightStyle.kIncludeLineSpacingTop: 3>
    kMax: typing.ClassVar[RectHeightStyle]  # value = <RectHeightStyle.kMax: 1>
    kStrut: typing.ClassVar[RectHeightStyle]  # value = <RectHeightStyle.kStrut: 5>
    kTight: typing.ClassVar[RectHeightStyle]  # value = <RectHeightStyle.kTight: 0>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RectWidthStyle:
    """
    Members:

      kTight

      kMax
    """

    __members__: typing.ClassVar[
        dict[str, RectWidthStyle]
    ]  # value = {'kTight': <RectWidthStyle.kTight: 0>, 'kMax': <RectWidthStyle.kMax: 1>}
    kMax: typing.ClassVar[RectWidthStyle]  # value = <RectWidthStyle.kMax: 1>
    kTight: typing.ClassVar[RectWidthStyle]  # value = <RectWidthStyle.kTight: 0>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class StrutStyle:
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, arg0: StrutStyle) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        fontFamilies: list[str] | None = None,
        fontStyle: animator.skia.FontStyle | None = None,
        fontSize: float | None = None,
        height: float | None = None,
        leading: float | None = None,
        strutEnabled: bool | None = None,
        forceStrutHeight: bool | None = None,
        heightOverride: bool | None = None,
        halfLeading: bool | None = None,
    ) -> None:
        """
        Construct a new strut style from keyword arguments. This creates a new :py:class:`StrutStyle` object
        and calls the respective setters for each keyword argument.
        """
    def __str__(self) -> str: ...
    def getFontFamilies(self) -> list: ...
    def getFontSize(self) -> float: ...
    def getFontStyle(self) -> animator.skia.FontStyle: ...
    def getForceStrutHeight(self) -> bool: ...
    def getHalfLeading(self) -> bool: ...
    def getHeight(self) -> float: ...
    def getHeightOverride(self) -> bool: ...
    def getLeading(self) -> float: ...
    def getStrutEnabled(self) -> bool: ...
    def setFontFamilies(self, families: list[str]) -> None: ...
    def setFontSize(self, size: float) -> None: ...
    def setFontStyle(self, fontStyle: animator.skia.FontStyle) -> None: ...
    def setForceStrutHeight(self, v: bool) -> None: ...
    def setHalfLeading(self, halfLeading: bool) -> None: ...
    def setHeight(self, height: float) -> None: ...
    def setHeightOverride(self, v: bool) -> None: ...
    def setLeading(self, Leading: float) -> None: ...
    def setStrutEnabled(self, v: bool) -> None: ...

class StyleMetrics:
    font_metrics: animator.skia.FontMetrics
    @typing.overload
    def __init__(self, style: TextStyle) -> None: ...
    @typing.overload
    def __init__(self, style: TextStyle, fontMetrics: animator.skia.FontMetrics) -> None: ...
    def __str__(self) -> str: ...
    @property
    def text_style(self) -> TextStyle: ...

class StyleType:
    """
    Members:

      kNone

      kAllAttributes

      kFont

      kForeground

      kBackground

      kShadow

      kDecorations

      kLetterSpacing

      kWordSpacing
    """

    __members__: typing.ClassVar[
        dict[str, StyleType]
    ]  # value = {'kNone': <StyleType.kNone: 0>, 'kAllAttributes': <StyleType.kAllAttributes: 1>, 'kFont': <StyleType.kFont: 2>, 'kForeground': <StyleType.kForeground: 3>, 'kBackground': <StyleType.kBackground: 4>, 'kShadow': <StyleType.kShadow: 5>, 'kDecorations': <StyleType.kDecorations: 6>, 'kLetterSpacing': <StyleType.kLetterSpacing: 7>, 'kWordSpacing': <StyleType.kWordSpacing: 8>}
    kAllAttributes: typing.ClassVar[StyleType]  # value = <StyleType.kAllAttributes: 1>
    kBackground: typing.ClassVar[StyleType]  # value = <StyleType.kBackground: 4>
    kDecorations: typing.ClassVar[StyleType]  # value = <StyleType.kDecorations: 6>
    kFont: typing.ClassVar[StyleType]  # value = <StyleType.kFont: 2>
    kForeground: typing.ClassVar[StyleType]  # value = <StyleType.kForeground: 3>
    kLetterSpacing: typing.ClassVar[StyleType]  # value = <StyleType.kLetterSpacing: 7>
    kNone: typing.ClassVar[StyleType]  # value = <StyleType.kNone: 0>
    kShadow: typing.ClassVar[StyleType]  # value = <StyleType.kShadow: 5>
    kWordSpacing: typing.ClassVar[StyleType]  # value = <StyleType.kWordSpacing: 8>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TextAlign:
    """
    Members:

      kLeft

      kRight

      kCenter

      kJustify

      kStart

      kEnd
    """

    __members__: typing.ClassVar[
        dict[str, TextAlign]
    ]  # value = {'kLeft': <TextAlign.kLeft: 0>, 'kRight': <TextAlign.kRight: 1>, 'kCenter': <TextAlign.kCenter: 2>, 'kJustify': <TextAlign.kJustify: 3>, 'kStart': <TextAlign.kStart: 4>, 'kEnd': <TextAlign.kEnd: 5>}
    kCenter: typing.ClassVar[TextAlign]  # value = <TextAlign.kCenter: 2>
    kEnd: typing.ClassVar[TextAlign]  # value = <TextAlign.kEnd: 5>
    kJustify: typing.ClassVar[TextAlign]  # value = <TextAlign.kJustify: 3>
    kLeft: typing.ClassVar[TextAlign]  # value = <TextAlign.kLeft: 0>
    kRight: typing.ClassVar[TextAlign]  # value = <TextAlign.kRight: 1>
    kStart: typing.ClassVar[TextAlign]  # value = <TextAlign.kStart: 4>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TextBaseline:
    """
    Members:

      kAlphabetic

      kIdeographic
    """

    __members__: typing.ClassVar[
        dict[str, TextBaseline]
    ]  # value = {'kAlphabetic': <TextBaseline.kAlphabetic: 0>, 'kIdeographic': <TextBaseline.kIdeographic: 1>}
    kAlphabetic: typing.ClassVar[TextBaseline]  # value = <TextBaseline.kAlphabetic: 0>
    kIdeographic: typing.ClassVar[TextBaseline]  # value = <TextBaseline.kIdeographic: 1>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TextBox:
    direction: TextDirection
    rect: animator.skia.Rect
    def __init__(self, rect: animator.skia.Rect, direction: TextDirection) -> None: ...
    def __str__(self) -> str: ...

class TextDecoration(IntEnum):
    """
    Members:

      kNoDecoration

      kUnderline

      kOverline

      kLineThrough
    """

    __members__: typing.ClassVar[
        dict[str, TextDecoration]
    ]  # value = {'kNoDecoration': <TextDecoration.kNoDecoration: 0>, 'kUnderline': <TextDecoration.kUnderline: 1>, 'kOverline': <TextDecoration.kOverline: 2>, 'kLineThrough': <TextDecoration.kLineThrough: 4>}
    kLineThrough: typing.ClassVar[TextDecoration]  # value = <TextDecoration.kLineThrough: 4>
    kNoDecoration: typing.ClassVar[TextDecoration]  # value = <TextDecoration.kNoDecoration: 0>
    kOverline: typing.ClassVar[TextDecoration]  # value = <TextDecoration.kOverline: 2>
    kUnderline: typing.ClassVar[TextDecoration]  # value = <TextDecoration.kUnderline: 1>
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TextDecorationMode:
    """
    Members:

      kGaps

      kThrough
    """

    __members__: typing.ClassVar[
        dict[str, TextDecorationMode]
    ]  # value = {'kGaps': <TextDecorationMode.kGaps: 0>, 'kThrough': <TextDecorationMode.kThrough: 1>}
    kGaps: typing.ClassVar[TextDecorationMode]  # value = <TextDecorationMode.kGaps: 0>
    kThrough: typing.ClassVar[TextDecorationMode]  # value = <TextDecorationMode.kThrough: 1>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TextDecorationStyle:
    """
    Members:

      kSolid

      kDouble

      kDotted

      kDashed

      kWavy
    """

    __members__: typing.ClassVar[
        dict[str, TextDecorationStyle]
    ]  # value = {'kSolid': <TextDecorationStyle.kSolid: 0>, 'kDouble': <TextDecorationStyle.kDouble: 1>, 'kDotted': <TextDecorationStyle.kDotted: 2>, 'kDashed': <TextDecorationStyle.kDashed: 3>, 'kWavy': <TextDecorationStyle.kWavy: 4>}
    kDashed: typing.ClassVar[TextDecorationStyle]  # value = <TextDecorationStyle.kDashed: 3>
    kDotted: typing.ClassVar[TextDecorationStyle]  # value = <TextDecorationStyle.kDotted: 2>
    kDouble: typing.ClassVar[TextDecorationStyle]  # value = <TextDecorationStyle.kDouble: 1>
    kSolid: typing.ClassVar[TextDecorationStyle]  # value = <TextDecorationStyle.kSolid: 0>
    kWavy: typing.ClassVar[TextDecorationStyle]  # value = <TextDecorationStyle.kWavy: 4>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TextDirection:
    """
    Members:

      kRtl

      kLtr
    """

    __members__: typing.ClassVar[
        dict[str, TextDirection]
    ]  # value = {'kRtl': <TextDirection.kRtl: 0>, 'kLtr': <TextDirection.kLtr: 1>}
    kLtr: typing.ClassVar[TextDirection]  # value = <TextDirection.kLtr: 1>
    kRtl: typing.ClassVar[TextDirection]  # value = <TextDirection.kRtl: 0>
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TextHeightBehavior(IntEnum):
    """
    Members:

      kAll

      kDisableFirstAscent

      kDisableLastDescent

      kDisableAll
    """

    __members__: typing.ClassVar[
        dict[str, TextHeightBehavior]
    ]  # value = {'kAll': <TextHeightBehavior.kAll: 0>, 'kDisableFirstAscent': <TextHeightBehavior.kDisableFirstAscent: 1>, 'kDisableLastDescent': <TextHeightBehavior.kDisableLastDescent: 2>, 'kDisableAll': <TextHeightBehavior.kDisableAll: 3>}
    kAll: typing.ClassVar[TextHeightBehavior]  # value = <TextHeightBehavior.kAll: 0>
    kDisableAll: typing.ClassVar[TextHeightBehavior]  # value = <TextHeightBehavior.kDisableAll: 3>
    kDisableFirstAscent: typing.ClassVar[TextHeightBehavior]  # value = <TextHeightBehavior.kDisableFirstAscent: 1>
    kDisableLastDescent: typing.ClassVar[TextHeightBehavior]  # value = <TextHeightBehavior.kDisableLastDescent: 2>
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TextShadow:
    __hash__: typing.ClassVar[None] = None
    fBlurSigma: float
    fColor: int
    fOffset: animator.skia.Point
    def __eq__(self, arg0: TextShadow) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self, color: _Color = animator.skia.ColorBLACK, offset: _Point = ..., blurSigma: float = 0
    ) -> None: ...
    def __ne__(self, arg0: TextShadow) -> bool: ...
    def hasShadow(self) -> bool: ...

class TextStyle:
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, arg0: TextStyle) -> bool: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: TextStyle) -> None: ...
    @typing.overload
    def __init__(
        self,
        color: _Color = ...,
        foregroundPaint: animator.skia.Paint = ...,
        backgroundPaint: animator.skia.Paint = ...,
        decoration: TextDecoration = ...,
        decorationMode: TextDecorationMode = ...,
        decorationStyle: TextDecorationStyle = ...,
        decorationColor: _Color = ...,
        decorationThicknessMultiplier: float = ...,
        fontStyle: animator.skia.FontStyle = ...,
        shadows: list[TextShadow] = ...,
        fontArguments: animator.skia.FontArguments = ...,
        fontSize: float = ...,
        fontFamilies: list[str] = ...,
        baselineShift: float = ...,
        height: float = ...,
        heightOverride: bool = ...,
        halfLeading: bool = ...,
        letterSpacing: float = ...,
        wordSpacing: float = ...,
        typeface: animator.skia.Typeface = ...,
        locale: str = ...,
        textBaseline: TextBaseline = ...,
        placeholder: bool = ...,
    ) -> None:
        """
        Construct a new text style from keyword arguments. This creates a new :py:class:`TextStyle` object and calls the
        respective setters for each keyword argument.

        Supported keyword arguments: ``color``, ``foregroundPaint``, ``backgroundPaint``, ``decoration``,
        ``decorationMode``, ``decorationStyle``, ``decorationColor``, ``decorationThicknessMultiplier``, ``fontStyle``,
        ``shadows``, ``fontArguments``, ``fontSize``, ``fontFamilies``, ``baselineShift``, ``height``,
        ``heightOverride``, ``halfLeading``, ``letterSpacing``, ``wordSpacing``, ``typeface``, ``locale``,
        ``textBaseline``, ``placeholder``.
        """
    def __str__(self) -> str: ...
    def addFontFeature(self, fontFeature: str, value: int) -> None: ...
    def addShadow(self, shadow: TextShadow) -> None: ...
    def clearBackgroundColor(self) -> None: ...
    def clearForegroundColor(self) -> None: ...
    def cloneForPlaceholder(self) -> TextStyle: ...
    def equals(self, other: TextStyle) -> bool: ...
    def equalsByFonts(self, that: TextStyle) -> bool: ...
    def getBackground(self) -> animator.skia.Paint: ...
    def getBaselineShift(self) -> float: ...
    def getColor(self) -> int: ...
    def getDecoration(self) -> Decoration: ...
    def getDecorationColor(self) -> int: ...
    def getDecorationMode(self) -> TextDecorationMode: ...
    def getDecorationStyle(self) -> TextDecorationStyle: ...
    def getDecorationThicknessMultiplier(self) -> float: ...
    def getDecorationType(self) -> TextDecoration: ...
    def getFontArguments(self) -> FontArguments | None: ...
    def getFontFamilies(self) -> list: ...
    def getFontFeatureNumber(self) -> int: ...
    def getFontFeatures(self) -> list[FontFeature]: ...
    def getFontMetrics(self) -> animator.skia.FontMetrics:
        """
        Returns the font metrics for the current font.
        """
    def getFontSize(self) -> float: ...
    def getFontStyle(self) -> animator.skia.FontStyle: ...
    def getForeground(self) -> animator.skia.Paint: ...
    def getHalfLeading(self) -> bool: ...
    def getHeight(self) -> float: ...
    def getHeightOverride(self) -> bool: ...
    def getLetterSpacing(self) -> float: ...
    def getLocale(self) -> str: ...
    def getShadowNumber(self) -> int: ...
    def getShadows(self) -> list[TextShadow]: ...
    def getTextBaseline(self) -> TextBaseline: ...
    def getTypeface(self) -> animator.skia.Typeface: ...
    def getWordSpacing(self) -> float: ...
    def hasBackground(self) -> bool: ...
    def hasForeground(self) -> bool: ...
    def isPlaceholder(self) -> bool: ...
    def matchOneAttribute(self, styleType: StyleType, other: TextStyle) -> bool: ...
    def refTypeface(self) -> animator.skia.Typeface: ...
    def resetFontFeatures(self) -> None: ...
    def resetShadows(self) -> None: ...
    def setBackgroundPaint(self, paint: animator.skia.Paint) -> None: ...
    def setBaselineShift(self, shift: float) -> None: ...
    def setColor(self, color: _Color) -> None: ...
    def setDecoration(self, decoration: TextDecoration) -> None: ...
    def setDecorationColor(self, color: _Color) -> None: ...
    def setDecorationMode(self, mode: TextDecorationMode) -> None: ...
    def setDecorationStyle(self, style: TextDecorationStyle) -> None: ...
    def setDecorationThicknessMultiplier(self, m: float) -> None: ...
    def setFontArguments(self, args: animator.skia.FontArguments | None) -> None: ...
    def setFontFamilies(self, families: list[str]) -> None: ...
    def setFontSize(self, size: float) -> None: ...
    def setFontStyle(self, style: animator.skia.FontStyle) -> None: ...
    def setForegroundPaint(self, paint: animator.skia.Paint) -> None: ...
    def setHalfLeading(self, halfLeading: bool) -> None: ...
    def setHeight(self, height: float) -> None: ...
    def setHeightOverride(self, heightOverride: bool) -> None: ...
    def setLetterSpacing(self, letterSpacing: float) -> None: ...
    def setLocale(self, locale: str) -> None: ...
    def setPlaceholder(self) -> None: ...
    def setTextBaseline(self, baseline: TextBaseline) -> None: ...
    def setTypeface(self, typeface: animator.skia.Typeface) -> None: ...
    def setWordSpacing(self, wordSpacing: float) -> None: ...
